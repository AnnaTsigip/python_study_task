#функция выполняется в том месте где она была вызвана. ее место в коде не имеет значение. но функция должна быть определена до точки запуска(вызова)
#1.

# def show():
#     print('функция')

# print('до функции')

# show() # команда вызова функции

# print('после функции')

# show()# повторный вызов, функция снова выполняется

'''
без return функция свою работу выполняет, но она ничего не возвращает для дальнейшего использования в программе
переменные из функции не видны в основном блоке(т.е. за пределами функции), но функции могут видеть переменные из основного блока программы
1.
def show2():
    x = 7
    return x 
y = show2() # присваиваем значение работы функции в переменную. 
z = show2() + 9 

print(y)
print(z)


2.

def show2():
    x = 7 + z
    return x 
z = 7 # но переменная должна быть указана до места вызова функции, 
y = show2() 
print(y) #14
z = 9# функция не видет значение переменной, т.к. стоит после места вызова функции print(y)
print(show2()) #16

'''

#параметры и аргументы функций:
#если не использовать функцию len. длину списка можем посчитать через цикл for.
# count = 0
# for i in j:
#     count+=1 
# чтобы каждый раз не переписывать подсчет длины можем записать в функцию

"""
def count_list(par): # parametr - переменная определенная внутри функции
    count = 0
    for i in par:
        count+=1
    return count


j = [9, 8, 7, 6]

print(count_list(j)) #argument


h = ['a', 'a', 'h']

print(count_list(h))

k = [1, 5, 9, 3, 5, 6, 7]

print(count_list(k))

print(count_list('stroka')) # можно сразу передать строку, и функция посчитает длину
"""

# в функцию можно прописать значение по умолчанию, т.е. сразу со значением count = 0,  тогда при вызове функции значение count указаывать не надо

# def count_list(par, count = 0): 
    
#     for i in par:
#         count+=1
#     return count

# k = [1, 5, 9, 3, 5, 6, 7]

# print(count_list(k))

####### если во второй переменной не указано сразу значение в функции count, то при вызове необходимо указывать и ее значение
# def count_list(par, count): 
    
#     for i in par:
#         count+=1
#     return count

# k = [1, 5, 9, 3, 5, 6, 7, 9]

# print(count_list(k, 0))

######### но даже если указано значение по умолчанию, при вызове функции можно указать другое

# def count_list(par, count = 0): 
    
#     for i in par:
#         count+=1
#     return count

# k = [1, 5, 9, 3, 5, 6, 7, 9]

# print(count_list(k, -1)) # покажет индекс последнего элемента, т.е. длина -1

# можем использовать 2 параметра по умолчанию:

# def count_list(par, par2 = False, count = 0): 
#     if par2 == True:
#         typ = type(par[0])
#         for i in par:
#             count+=1
#         return count, typ

#     else:
#         for i in par:
#             count += 1
#         return count

# k = [1, 5, 9, 3, 5, 6, 7, 9]

# print(count_list(k)) # par2 = False, count = 0 по умолчанию
# print(count_list(k, True)) # если изменяем значение 2 переменной
# print(count_list(k, count = -1)) # если изменяем значение 3 переменной
# print(count_list(k, True, -1)) # если все 3 указываем

# print(count_list(k, True)) # -  по сути кортеж, можно распаковать по переменным
# h, p = count_list(k, True)
# print(h)
# print(p)

"""
как передать функции переменное количество аргументов *args * называется астериск

def name(*args): # переменная записываетсся как args чтобы и другие понимали, что это
    print(args)

name(7,) # кортеж (7,)
name(7, 8, 9, 1) # кортеж помещается в переменную (7, 8, 9, 1)
name() # создается пустой кортеж ()

###################
def name(h, g, *args): # помимо аrgs могут быть дополнительные параметры, тогда в них записывается по одному неименованному аргументу, все остальное в аrgs
    print(h) #7
    print(g) # 8
    print(args) # ( 9, 1))

name(7, 8, 9, 1)

##############

def name(h = 2, g = 5, *args): # даже если будут указаны значения по умолчанию, они изменятся
    print(h) #7
    print(g) # 8
    print(args) # ( 9, 1))

name(7, 8, 9, 1)

###############################

def name(h = 2, g = 5, *args, key): # дополнительные параменты для управления функции записываются после  аrgs и называются ключевые параметры, 
    # в них значения можно присвоить только при помощи именнованного аргумента имя - имя параментра, которому присваивается значение. 
    # если аргумент не именовать - будет ошибка, все неименованные попадут в args  а key не будет назначен аргумент
    print(h) #7
    print(g) # 8
    print(args) # ( 9, 1))
    print(key) # 10

name(7, 8, 9, 1, key = 10)

"""

#пример:
# создадим функцию, в которую будут передаваться данные, а она возвращать только уникальные значения
1. 

# def exclusive_item(*args):
#     new_list = []
#     for i in args:
#         for y in i:
#             if y not in new_list:
#                 new_list.append(y)
#     return new_list

# z=[1,2,3,4,5]
# x=[2,2,5,8,10,12]
# c=[9,11,12,4]

# t = exclusive_item(z,x,c)
# print(t) #[1, 2, 3, 4, 5, 8, 10, 12, 9, 11]


# ****************************************

# 2. добавляем ключевой параметр для сортировки :
# def exclusive_item(*args, key = False):
#     new_list = []
#     for i in args:
#         for y in i:
#             if y not in new_list:
#                 new_list.append(y)
#     if key == True:
#         new_list.sort()
#     return new_list

# z=[1,2,3,4,5]
# x=[2,2,5,8,10,12]
# c=[9,11,12,4]

# t = exclusive_item(z,x,c, key = True)
# print(t) #[1, 2, 3, 4, 5, 8, 9, 10, 11, 12]
# t = exclusive_item(z,x,c) #если не указать key = True то [1, 2, 3, 4, 5, 8, 10, 12, 9, 11]


"""
Функции область видимости переменных
2 зоны видимости:
глобальная и локальная(функции и класс)


глобальная область видимости:
x = 5

count = 0
while count < 3:
    count+=1

print(count)


 ********************************************


локальная:
1. переменная в функции:


x=5

def name():
    y=10 # находится в локальной области функции
    print(x)
    return y # сможем использовать значение, но не саму переменную


h = name() #10
print(h)
print(y) # NameError: name 'y' is not defined - переменная недоступна

***********************

x=5 # глобальная область видимости

def name():
    #x=10 # локальная область видимости
    x+=10 # UnboundLocalError: local variable 'x' referenced before assignment, т.к. переменная локальная, менять глобальный х не сможем

    print(x)

name() #10
print(x) #5


*********************************
global - мы не создаем новую локальную переменную, а хотим внести изменения в глобальную

x=5 # глобальная область видимости

def name():
    global x
    x = 100 # локальная область видимости
    
    print(x)

name() 
print(x)
"""

# если нужно использовать переменную из одной функциив другой:
# можно переменную из первой функции записать в другую переменную и ее уже использовать в другой функции, но это долго и код захламлен:


# x = 5

# def name():
#     x = 100
#     return x

# h = name()

# def name2():
#     print(h)

# name2()

# ***********************************************

#лучше так:

# x = 5

# def name():
#     x = 100
#     return name2(x)


# def name2(par):
#     print(par)

# name()

#*************************************************************

"""
 фунцкия объявлена в функции
 у каждой функции своя локальная область видимости

здесь все переменные разные, со своими значениями

 x = 5

def name():
    x = 10
    def name2():
        x = 100
        print(x)
     
    name2() #100
    print(x)

name() # 10
print(x) # 5


№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№


# если нужно изменить , а не создать новую: nonlocal, тогда переменная меняется в рамках функций
 не создаем новую переменную, а меняем значение переменной х из первой функции

 x = 5

def name():
    x = 10
    def name2():
        nonlocal x
        x = 100
        print(x)
     
    name2() #100
    print(x)

name() # 100
print(x) # 5
 """


#################################################################################

#функции и структура кода

# программа вычисления объем цилиндра:

import math # модуль math

PI = math.pi # объявляется переменная в нее берется значение числа пи из модуля

def radius():
    n = float (input('диаметр цилиндра в см ' ))
    n /= 2 # радиус
    return n

def height():
    m = float(input("высота цилиндра в см " ))
    return m


def volume():
    r = radius()
    h = height()
    s = PI*r**2 # площадь круга
    v = s * h # объем цилиндра

    return v

print(f'Объем цилиндра {volume()} см3')

# посчитаем вес цилиндра:

def massa(g): # будет приходить объем цилиндра
    n = float (input('удельный вес г/см3 ' ))
    return g *n/1000
print(f'вес цилиндра в кг:{massa(volume())}')


